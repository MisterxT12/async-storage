{"searchDocs":[{"title":"Dedicator Thread Executor","type":0,"sectionRef":"#","url":"/async-storage/docs/advanced/executor","content":"","keywords":"","version":"Next"},{"title":"Motivation​","type":1,"pageTitle":"Dedicator Thread Executor","url":"/async-storage/docs/advanced/executor#motivation","content":"This feature would be mostly used in brownfield apps and in edge cases with some android devices.Dedicated thread pool executor makes AsyncStorage use separate thread pool for its tasks execution. Use this feature if THREAD_POOL_EXECUTOR from AsyncTasks: Is used in your app, so that background tasks are queued most of the timeActs weird on your device (for example, waits for some time before execution) ","version":"Next","tagName":"h2"},{"title":"How to use​","type":1,"pageTitle":"Dedicator Thread Executor","url":"/async-storage/docs/advanced/executor#how-to-use","content":"Add a AsyncStorage_dedicatedExecutor property to your android/gradle.properties: AsyncStorage_dedicatedExecutor=true  ","version":"Next","tagName":"h2"},{"title":"Increasing Storage size","type":0,"sectionRef":"#","url":"/async-storage/docs/advanced/db_size","content":"","keywords":"","version":"Next"},{"title":"Motivation​","type":1,"pageTitle":"Increasing Storage size","url":"/async-storage/docs/advanced/db_size#motivation","content":"Current Async Storage's size is set to 6MB. Going over this limit causes database or disk is full error. This 6MB limit is a sane limit to protect the user from the app storing too much data in the database. This also protects the database from filling up the disk cache and becoming malformed (endTransaction() calls will throw an exception, not rollback, and leave the db malformed). You have to be aware of that risk when increasing the database size. We recommend to ensure that your app does not write more data to AsyncStorage than space is left on disk. Since AsyncStorage is based on SQLite on Android you also have to be aware of the SQLite limits. ","version":"Next","tagName":"h2"},{"title":"Increase limit​","type":1,"pageTitle":"Increasing Storage size","url":"/async-storage/docs/advanced/db_size#increase-limit","content":"Add a AsyncStorage_db_size_in_MB property to your android/gradle.properties: AsyncStorage_db_size_in_MB=10  Now you can define the new size in MB. In this example, the new limit is 10 MB. ","version":"Next","tagName":"h2"},{"title":"Brownfield integration","type":0,"sectionRef":"#","url":"/async-storage/docs/advanced/brownfield","content":"","keywords":"","version":"Next"},{"title":"The protocol​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#the-protocol","content":"The delegate must conform to the RNCAsyncStorageDelegate protocol: ","version":"Next","tagName":"h2"},{"title":"allKeys​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#allkeys","content":"- (void)allKeys:(RNCAsyncStorageResultCallback)block;  Returns all keys currently stored. If none, an empty array is returned. Called by getAllKeys in JS. ","version":"Next","tagName":"h3"},{"title":"mergeValues​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#mergevalues","content":"- (void)mergeValues:(NSArray&lt;NSString *&gt; *)values forKeys:(NSArray&lt;NSString *&gt; *)keys completion:(RNCAsyncStorageResultCallback)block;  Merges values with the corresponding values stored at specified keys. Called by mergeItem and multiMerge in JS. ","version":"Next","tagName":"h3"},{"title":"removeAllValues​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#removeallvalues","content":"- (void)removeAllValues:(RNCAsyncStorageCompletion)block;  Removes all values from the store. Called by clear in JS. ","version":"Next","tagName":"h3"},{"title":"removeValuesForKeys​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#removevaluesforkeys","content":"- (void)removeValuesForKeys:(NSArray&lt;NSString *&gt; *)keys completion:(RNCAsyncStorageResultCallback)block;  Removes all values associated with specified keys. Called by removeItem and multiRemove in JS. ","version":"Next","tagName":"h3"},{"title":"setValues​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#setvalues","content":"- (void)setValues:(NSArray&lt;NSString *&gt; *)values forKeys:(NSArray&lt;NSString *&gt; *)keys completion:(RNCAsyncStorageResultCallback)block;  Sets specified key-value pairs. Called by setItem and multiSet in JS. ","version":"Next","tagName":"h3"},{"title":"valuesForKeys​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#valuesforkeys","content":"- (void)valuesForKeys:(NSArray&lt;NSString *&gt; *)keys completion:(RNCAsyncStorageResultCallback)block;  Returns values associated with specified keys. Called by getItem and multiGet in JS. ","version":"Next","tagName":"h3"},{"title":"passthrough​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#passthrough","content":"@optional @property (nonatomic, readonly, getter=isPassthrough) BOOL passthrough;  Optional: Returns whether the delegate should be treated as a passthrough. This is useful for monitoring storage usage among other things. Returns NO by default.  Android The recommended approach here is to use Kotlin language to leverage coroutines when accessing the storage. Java is also supported (through Kotlin interop), but the approach is more cumbersome. ","version":"Next","tagName":"h3"},{"title":"Prerequisites​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#prerequisites","content":"Next storage feature enabled.Add dependency on coroutines-android in your app's build.gradle  dependencies { // other dependencies // will work with coroutines 1.3.0 and up + implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9&quot; }  Your library of choice for parsing JSON storage values (since there are strings only) ","version":"Next","tagName":"h2"},{"title":"Access storage​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#access-storage","content":"","version":"Next","tagName":"h2"},{"title":"Kotlin (recommended)​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#kotlin-recommended","content":"We use Coroutines to handle asynchronous code. Each method on storage is suspend method, so you need to call it from within a coroutine. Reading value​ suspend fun readValue(ctx: Context, keys: List&lt;String&gt;) { // get instance of the Storage by providing context object val asyncStorage = StorageModule.getStorageInstance(ctx) val entries: List&lt;Entry&gt; = asyncStorage.getValues(keys) doSomethingWithValues(entries) }  Saving value​ suspend fun saveValue(ctx: Context) { val asyncStorage = StorageModule.getStorageInstance(ctx) val entries = listOf( Entry(&quot;myKey&quot;, &quot;myValue&quot;) ) asyncStorage.setValues(entries) }  ","version":"Next","tagName":"h3"},{"title":"Java​","type":1,"pageTitle":"Brownfield integration","url":"/async-storage/docs/advanced/brownfield#java","content":"You can access AsyncStorage form Java, but you're still required to add Kotlin dependencies. There's no one way of accessing the data and there's more than one way to parse it. Reading from storage​ void readStorageValue(Context ctx, String key) { AsyncStorageAccess asyncStorage = StorageModule.getStorageInstance(ctx); BuildersKt.launch(GlobalScope.INSTANCE, Dispatchers.getIO(), CoroutineStart.DEFAULT, (scope, continuation) -&gt; { List&lt;String&gt; keys = new ArrayList&lt;&gt;(); keys.add(key); Continuation&lt;? super List&lt;? extends Entry&gt;&gt; cont = new Continuation() { @NotNull @Override public CoroutineContext getContext() { return scope.getCoroutineContext(); } @Override public void resumeWith(@NotNull Object o) { List&lt;Entry&gt; entries = (List&lt;Entry&gt;) o; doSomethingWithEntries(entries); } }; asyncStorage.getValues(keys, cont); return Unit.INSTANCE; }); }  Saving to storage​ void saveStorageValue(Context ctx, String key, String value) { AsyncStorageAccess asyncStorage = StorageModule.getStorageInstance(ctx); BuildersKt.launch(GlobalScope.INSTANCE, Dispatchers.getIO(), CoroutineStart.DEFAULT, (scope, continuation) -&gt; { Continuation cont = new Continuation() { @NotNull @Override public CoroutineContext getContext() { return scope.getCoroutineContext(); } @Override public void resumeWith(@NotNull Object o) {} }; List&lt;Entry&gt; entries = new ArrayList&lt;&gt;(); Entry entry = new Entry(key, value); entries.add(entry); asyncStorage.setValues(entries, cont); return Unit.INSTANCE; }); }  ","version":"Next","tagName":"h3"},{"title":"Database backup exclusion","type":0,"sectionRef":"#","url":"/async-storage/docs/advanced/backup","content":"Database backup exclusion Supported platforms: iOS/MacOS Async Storage stores data in Application Support directory, which is backed up by iCloud by default. This can lead to unintentional behavior where data is persisted even after an app re-installation. Async Storage disables that feature by default. In order to enable iCloud backup, open your app's info.plist in Xcode and add boolean entry called RCTAsyncStorageExcludeFromBackup and set its value to NO (NO as no for exclusion). Alternatively, you can open info.plist in editor and add new entry: + &lt;key&gt;RCTAsyncStorageExcludeFromBackup&lt;/key&gt; + &lt;false/&gt; ","keywords":"","version":"Next"},{"title":"Jest integration","type":0,"sectionRef":"#","url":"/async-storage/docs/advanced/jest","content":"","keywords":"","version":"Next"},{"title":"Using Async Storage mock​","type":1,"pageTitle":"Jest integration","url":"/async-storage/docs/advanced/jest#using-async-storage-mock","content":"You can use one of two ways to provide mocked version of AsyncStorage: ","version":"Next","tagName":"h2"},{"title":"With mocks directory​","type":1,"pageTitle":"Jest integration","url":"/async-storage/docs/advanced/jest#with-mocks-directory","content":"In your project root directory, create__mocks__/@react-native-async-storage directory.Inside that folder, create async-storage.js file.Inside that file, export Async Storage mock. export * from '@react-native-async-storage/async-storage/jest/async-storage-mock';  ","version":"Next","tagName":"h3"},{"title":"With Jest setup file​","type":1,"pageTitle":"Jest integration","url":"/async-storage/docs/advanced/jest#with-jest-setup-file","content":"In your Jest config (probably in package.json) add setup files location: &quot;jest&quot;: { &quot;setupFiles&quot;: [&quot;./path/to/jestSetupFile.js&quot;] }  Inside your setup file, set up Async Storage mocking: jest.mock('@react-native-async-storage/async-storage', () =&gt; require('@react-native-async-storage/async-storage/jest/async-storage-mock') );  ","version":"Next","tagName":"h3"},{"title":"Testing with mock​","type":1,"pageTitle":"Jest integration","url":"/async-storage/docs/advanced/jest#testing-with-mock","content":"Each public method available from Async Storage isa mock function, that you can test for certain condition, for example, if .getItem has been called with a specific arguments: it('checks if Async Storage is used', async () =&gt; { await asyncOperationOnAsyncStorage(); expect(AsyncStorage.getItem).toBeCalledWith('myKey'); });  ","version":"Next","tagName":"h2"},{"title":"Overriding Mock logic​","type":1,"pageTitle":"Jest integration","url":"/async-storage/docs/advanced/jest#overriding-mock-logic","content":"You can override mock implementation, by replacing its inner functions: // somewhere in your configuration files import AsyncStorageMock from '@react-native-async-storage/async-storage/jest/async-storage-mock'; AsyncStorageMock.multiGet = jest.fn(([keys], callback) =&gt; { // do something here to retrieve data callback([]); }); export default AsyncStorageMock;  You cancheck its implementationto get more insight into methods signatures. ","version":"Next","tagName":"h2"},{"title":"Where your data is stored","type":0,"sectionRef":"#","url":"/async-storage/docs/advanced/where_data_stored","content":"Where your data is stored Android - SQLiteiOS - small values (not exceeding 1024 characters) are serialized and stored in a common manifest.json file, while larger values are stored in individual, dedicated files (named as MD5 hashed key)macOS - Same as iOSWeb - window.localStorageWindows - SQLite","keywords":"","version":"Next"},{"title":"Community Packages","type":0,"sectionRef":"#","url":"/async-storage/docs/debugging/communityPackages","content":"","keywords":"","version":"Next"},{"title":"Flipper​","type":1,"pageTitle":"Community Packages","url":"/async-storage/docs/debugging/communityPackages#flipper","content":"For projects that use Flipper, there is a Flipper plugin called Advanced Async Storage. The plugin provides basic CRUD operations on Async Storage. ","version":"Next","tagName":"h3"},{"title":"Non Flipper​","type":1,"pageTitle":"Community Packages","url":"/async-storage/docs/debugging/communityPackages#non-flipper","content":"For the projects which aren't using Flipper, you can use the React Native Debugger which comes with a built-in Async Storage support. The debugger allows to print the Async Storage content to the console, and clear it completely. ","version":"Next","tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/async-storage/docs/install","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"Installation","url":"/async-storage/docs/install#install","content":"With npm: npm install @react-native-async-storage/async-storage  With Yarn: yarn add @react-native-async-storage/async-storage  With Expo CLI: npx expo install @react-native-async-storage/async-storage  ","version":"Next","tagName":"h3"},{"title":"Link​","type":1,"pageTitle":"Installation","url":"/async-storage/docs/install#link","content":"Android &amp; iOS​ Requires React Native 0.60+ CLI autolink featurelinks the module while building the app. On iOS, use CocoaPods to add the native RNAsyncStorage to your project: npx pod-install  Windows​ Requires React Native Windows 0.63+ CLI autolink featurelinks the module while building the app. macOS​ Requires React Native macOS 0.63+ Set platform :macos, '10.14' in macos/PodfileInstall the podsFrom now onCLI autolink featurewill link the module while building the app. ","version":"Next","tagName":"h3"},{"title":"Next storage implementation","type":0,"sectionRef":"#","url":"/async-storage/docs/advanced/next","content":"","keywords":"","version":"Next"},{"title":"Motivation​","type":1,"pageTitle":"Next storage implementation","url":"/async-storage/docs/advanced/next#motivation","content":"Current implementation of persistence layer is created using SQLiteOpenHelper, a helper class that manages database creation and migrations. Even if this approach is powerful, the lack of compile time query verification and a big boilerplate of mapping SQLite queries to actual values make this implementation prone to many errors. This Async Storage feature improves the persistence layer, using modern approaches to access SQLite (using Room), to reduce possible anomalies to the minimum. On top of that, it allows accessing AsyncStorage from the native side, useful in Brownfield integration. ","version":"Next","tagName":"h3"},{"title":"Migration​","type":1,"pageTitle":"Next storage implementation","url":"/async-storage/docs/advanced/next#migration","content":"This feature requires no migration from the developer perspective - the current database will be recreated (based on the current one), meaning user won't lose any data if you decide to opt in. There's a small drawback to know - the database &quot;recreation&quot; happens only once. How it works​ The new database (the one used by this feature) will be created based on the current database file, if the new one does not exist yet. If we detect that there's already the new database on the device, recreation will not kick in. Why is it important​ Let's say you enabled the feature for the first time - recreation kicks in and the old database file is untouched. If you decide to disable the feature, your users will be back using old database. No data migrations is happening from new to old database file. When you enable the feature again, the new database is not recreated, because it already exists, and no data is copied over. ","version":"Next","tagName":"h3"},{"title":"Enable​","type":1,"pageTitle":"Next storage implementation","url":"/async-storage/docs/advanced/next#enable","content":"Add config flag​ In your project's android directory, locate gradle.properties file (if it does not exist, create one) and add the line: AsyncStorage_useNextStorage=true  React Native &lt; 0.73​ For React Native below version 0.73, you need to apply Kotlin plugin to your project. In your project's android directory, locate root build.gradle file. Add Kotlin dependency to the buildscript:  buildscript { ext { // other extensions + kotlinVersion = '1.9.24' } dependencies { // other dependencies + classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion&quot; } }  ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"Next storage implementation","url":"/async-storage/docs/advanced/next#configuration","content":"Kotlin version Next storage is tested against Kotlin version 1.9.24. You can specify different version, in one of two ways: add kotlinVersion extension to the rootProject: rootProject.ext.kotlinVersion = '1.9.24'  specify AsyncStorage_kotlinVersion in gradle.properties: AsyncStorage_kotlinVersion=1.9.24  Room Next AsyncStorage uses Room persistence library to store data. Currently, tested version is 2.6.1. You can specify different version, by adding a flag to gradle.properties: AsyncStorage_next_roomVersion=2.6.1  KSP is enabled for symbol processing for the Room library. KSP version will be selected based on Kotlin version in your project. If you want to use different KSP version, you can set a property in gradle.properties: AsyncStorage_next_kspVersion=1.9.24-1.0.20  ","version":"Next","tagName":"h3"},{"title":"Notable changes​","type":1,"pageTitle":"Next storage implementation","url":"/async-storage/docs/advanced/next#notable-changes","content":"Alongside of a warning regarding key/value, errors are thrown when: Your key is null or not a stringYou provide value that is not a string ","version":"Next","tagName":"h3"},{"title":"Known storage limits","type":0,"sectionRef":"#","url":"/async-storage/docs/limits","content":"","keywords":"","version":"Next"},{"title":"Android​","type":1,"pageTitle":"Known storage limits","url":"/async-storage/docs/limits#android","content":"AsyncStorage for Android uses SQLite for storage backend. While it has its own size limits, Android system also have two known limits: total storage size and per-entry size limit. Total storage size is capped at 6 MB by default. You can increase this size by specifying a new size using feature flag. Per-entry is limited by a size of a WindowCursor, a buffer used to read data from SQLite. Currently it's size is around 2 MB. This means that the single item read at one time cannot be larger than 2 MB. There's no supported workaround from AsyncStorage. We suggest keeping your data lower than that, by chopping it down into many entries, instead of one massive entry. This is where multiGet and multiSet APIs can shine. ","version":"Next","tagName":"h2"},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"/async-storage/docs/help/troubleshooting","content":"","keywords":"","version":"Next"},{"title":"Async await doesn't resolve​","type":1,"pageTitle":"Troubleshooting","url":"/async-storage/docs/help/troubleshooting#async-await-doesnt-resolve","content":"If you're having issues with getItem() and friends not resolving, check ifinlineRequires is enabled in metro.config.js: module.exports = { transformer: { getTransformOptions: async () =&gt; ({ transform: { experimentalImportSupport: false, inlineRequires: true, }, }), }, };  If disabling it resolves the issue, it's likely that you hit a circular import chain. You can try excluding @react-native-async-storage/async-storage from being inlined:  module.exports = { transformer: { getTransformOptions: async () =&gt; ({ transform: { experimentalImportSupport: false, inlineRequires: true, + nonInlinedRequires: [ + &quot;@react-native-async-storage/async-storage&quot;, + 'React', + 'react', + 'react-native', + ], }, }), }, };  If this doesn't resolve the issue, you need to figure out what is causing the cyclic chain. There are tools, such as@rnx-kit/metro-plugin-cyclic-dependencies-detector, that can help you debug this. ","version":"Next","tagName":"h2"},{"title":"[iOS] CocoaPods issues​","type":1,"pageTitle":"Troubleshooting","url":"/async-storage/docs/help/troubleshooting#ios-cocoapods-issues","content":"Delete the node_modules folder(s) from your projectRun yarn or npm installIf you're using CocoaPods: Make sure your Podfile does not have an entry for RNCAsyncStorage.pod installpod update RNCAsyncStorage Open your Xcode projectPress ⇧⌥⌘K to clean your build folderBuild and run your project Note that every time @react-native-async-storage/async-storage gets updated, you must also run pod update RNCAsyncStorage otherwise you'll still be using the previous version. ","version":"Next","tagName":"h2"},{"title":"[iOS] fatal error: 'React/RCTBridgeModule.h' file not found​","type":1,"pageTitle":"Troubleshooting","url":"/async-storage/docs/help/troubleshooting#ios-fatal-error-reactrctbridgemoduleh-file-not-found","content":"info In file included from /~/@react-native-async-storage/async-storage/ios/RNCAsyncStorage.m:8: /~/@react-native-async-storage/async-storage/ios/RNCAsyncStorage.h:8:9: fatal error: 'React/RCTBridgeModule.h' file not found info #import &lt;React/RCTBridgeModule.h&gt; ^~~~~~~~~~~~~~~~~~~~~~~~~ info 1 error generated.  Make sure that you've run pod install or pod update RNCAsyncStorage (see also CocoaPods issues). Make sure that React dependencies are not removed from projects. Without the target dependency set, Xcode may build things out of order and the React headers will not be installed when AsyncStorage is built. post_install do |installer| installer.pods_project.targets.each do |target| if target.name == &quot;React&quot; target.remove_from_project end end end Try switching back to the legacy build system in Xcode. You can find it in File &gt; Project/Workspace Settings sheet. ","version":"Next","tagName":"h2"},{"title":"[@RNC/AsyncStorage]: NativeModule: AsyncStorage is null​","type":1,"pageTitle":"Troubleshooting","url":"/async-storage/docs/help/troubleshooting#rncasyncstorage-nativemodule-asyncstorage-is-null","content":"","version":"Next","tagName":"h2"},{"title":"iOS​","type":1,"pageTitle":"Troubleshooting","url":"/async-storage/docs/help/troubleshooting#ios","content":"This error means that AsyncStorage was unable to find its native module. This occurs because AsyncStorage was not linked into the final app bundle. Make sure that you've run pod install or pod update RNCAsyncStorage (see also CocoaPods issues). ","version":"Next","tagName":"h3"},{"title":"Usage","type":0,"sectionRef":"#","url":"/async-storage/docs/usage","content":"","keywords":"","version":"Next"},{"title":"Importing​","type":1,"pageTitle":"Usage","url":"/async-storage/docs/usage#importing","content":"import AsyncStorage from '@react-native-async-storage/async-storage';  ","version":"Next","tagName":"h3"},{"title":"Storing data​","type":1,"pageTitle":"Usage","url":"/async-storage/docs/usage#storing-data","content":"setItem() is used both to add new data item (when no data for given key exists), and to modify existing item (when previous data for given key exists). Storing string value​ const storeData = async (value) =&gt; { try { await AsyncStorage.setItem('my-key', value); } catch (e) { // saving error } };  Storing object value​ const storeData = async (value) =&gt; { try { const jsonValue = JSON.stringify(value); await AsyncStorage.setItem('my-key', jsonValue); } catch (e) { // saving error } };  ","version":"Next","tagName":"h3"},{"title":"Reading data​","type":1,"pageTitle":"Usage","url":"/async-storage/docs/usage#reading-data","content":"getItem returns a promise that either resolves to stored value when data is found for given key, or returns null otherwise. Reading string value​ const getData = async () =&gt; { try { const value = await AsyncStorage.getItem('my-key'); if (value !== null) { // value previously stored } } catch (e) { // error reading value } };  Reading object value​ const getData = async () =&gt; { try { const jsonValue = await AsyncStorage.getItem('my-key'); return jsonValue != null ? JSON.parse(jsonValue) : null; } catch (e) { // error reading value } };  ","version":"Next","tagName":"h3"},{"title":"More​","type":1,"pageTitle":"Usage","url":"/async-storage/docs/usage#more","content":"For more examples, head over to API section. ","version":"Next","tagName":"h3"},{"title":"API","type":0,"sectionRef":"#","url":"/async-storage/docs/api","content":"","keywords":"","version":"Next"},{"title":"getItem​","type":1,"pageTitle":"API","url":"/async-storage/docs/api#getitem","content":"Gets a string value for given key. This function can either return a string value for existing key or return null otherwise. In order to store object value, you need to deserialize it, e.g. using JSON.parse(). Note (legacy): you can use optional callback as an alternative for returned promise. Signature: static getItem(key: string, [callback]: ?(error: ?Error, result: ?string) =&gt; void): Promise  Returns: Promise resolving with a string value, if entry exists for given key, or null otherwise. Promise can also be rejected in case of underlying storage error. Example: getMyStringValue = async () =&gt; { try { return await AsyncStorage.getItem('@key') } catch(e) { // read error } console.log('Done.') }  getMyObject = async () =&gt; { try { const jsonValue = await AsyncStorage.getItem('@key') return jsonValue != null ? JSON.parse(jsonValue) : null } catch(e) { // read error } console.log('Done.') }    ","version":"Next","tagName":"h2"},{"title":"setItem​","type":1,"pageTitle":"API","url":"/async-storage/docs/api#setitem","content":"Sets a string value for given key. This operation can either modify an existing entry, if it did exist for given key, or add new one otherwise. In order to store object value, you need to serialize it, e.g. using JSON.stringify(). Note (legacy): you can use optional callback as an alternative for returned promise. Signature: static setItem(key: string, value: string, [callback]: ?(error: ?Error) =&gt; void): Promise  Returns: Promise resolving when the set operation is completed. Promise can also be rejected in case of underlying storage error. Example: setStringValue = async (value) =&gt; { try { await AsyncStorage.setItem('key', value) } catch(e) { // save error } console.log('Done.') }  setObjectValue = async (value) =&gt; { try { const jsonValue = JSON.stringify(value) await AsyncStorage.setItem('key', jsonValue) } catch(e) { // save error } console.log('Done.') }    ","version":"Next","tagName":"h2"},{"title":"mergeItem​","type":1,"pageTitle":"API","url":"/async-storage/docs/api#mergeitem","content":"Merges an existing value stored under key, with new value, assuming both values are stringified JSON. Signature: static mergeItem(key: string, value: string, [callback]: ?(error: ?Error) =&gt; void): Promise  Returns: Promise with merged data, if exists, null otherwise. Example: const USER_1 = { name: 'Tom', age: 20, traits: { hair: 'black', eyes: 'blue' } } const USER_2 = { name: 'Sarah', age: 21, hobby: 'cars', traits: { eyes: 'green', } } mergeUsers = async () =&gt; { try { //save first user await AsyncStorage.setItem('@MyApp_user', JSON.stringify(USER_1)) // merge USER_2 into saved USER_1 await AsyncStorage.mergeItem('@MyApp_user', JSON.stringify(USER_2)) // read merged item const currentUser = await AsyncStorage.getItem('@MyApp_user') console.log(currentUser) // console.log result: // { // name: 'Sarah', // age: 21, // hobby: 'cars', // traits: { // eyes: 'green', // hair: 'black' // } // } } }    ","version":"Next","tagName":"h2"},{"title":"removeItem​","type":1,"pageTitle":"API","url":"/async-storage/docs/api#removeitem","content":"Removes item for a key, invokes (optional) callback once completed. Signature: static removeItem(key: string, [callback]: ?(error: ?Error) =&gt; void): Promise  Returns: Promise object. Example: removeValue = async () =&gt; { try { await AsyncStorage.removeItem('@MyApp_key') } catch(e) { // remove error } console.log('Done.') }    ","version":"Next","tagName":"h2"},{"title":"getAllKeys​","type":1,"pageTitle":"API","url":"/async-storage/docs/api#getallkeys","content":"Returns all keys known to your App, for all callers, libraries, etc. Once completed, invokes callback with errors (if any) and array of keys. Signature: static getAllKeys([callback]: ?(error: ?Error, keys: ?Array&lt;string&gt;) =&gt; void): Promise  Returns: Promise object. Example: getAllKeys = async () =&gt; { let keys = [] try { keys = await AsyncStorage.getAllKeys() } catch(e) { // read key error } console.log(keys) // example console.log result: // ['@MyApp_user', '@MyApp_key'] }    ","version":"Next","tagName":"h2"},{"title":"multiGet​","type":1,"pageTitle":"API","url":"/async-storage/docs/api#multiget","content":"Fetches multiple key-value pairs for given array of keys in a batch. Once completed, invokes callback with errors (if any) and results. Signature: static multiGet(keys: Array&lt;string&gt;, [callback]: ?(errors: ?Array&lt;Error&gt;, result: ?Array&lt;Array&lt;string&gt;&gt;) =&gt; void): Promise  Returns: Promise of array with coresponding key-value pairs found, stored as [key, value] array. Example: getMultiple = async () =&gt; { let values try { values = await AsyncStorage.multiGet(['@MyApp_user', '@MyApp_key']) } catch(e) { // read error } console.log(values) // example console.log output: // [ ['@MyApp_user', 'myUserValue'], ['@MyApp_key', 'myKeyValue'] ] }    ","version":"Next","tagName":"h2"},{"title":"multiSet​","type":1,"pageTitle":"API","url":"/async-storage/docs/api#multiset","content":"Stores multiple key-value pairs in a batch. Once completed, callback with any errors will be called. Signature: static multiSet(keyValuePairs: Array&lt;Array&lt;string&gt;&gt;, [callback]: ?(errors: ?Array&lt;Error&gt;) =&gt; void): Promise  Returns: Promise object. Example: multiSet = async () =&gt; { const firstPair = [&quot;@MyApp_user&quot;, &quot;value_1&quot;] const secondPair = [&quot;@MyApp_key&quot;, &quot;value_2&quot;] try { await AsyncStorage.multiSet([firstPair, secondPair]) } catch(e) { //save error } console.log(&quot;Done.&quot;) }    ","version":"Next","tagName":"h2"},{"title":"multiMerge​","type":1,"pageTitle":"API","url":"/async-storage/docs/api#multimerge","content":"Multiple merging of existing and new values in a batch. Assumes that values are stringified JSON. Once completed, invokes callback with errors (if any). Signature: static multiMerge(keyValuePairs: Array&lt;Array&lt;string&gt;&gt;, [callback]: ?(errors: ?Array&lt;Error&gt;) =&gt; void): Promise  Returns: Promise object. Example: const USER_1 = { name: 'Tom', age: 30, traits: {hair: 'brown'}, }; const USER_1_DELTA = { age: 31, traits: {eyes: 'blue'}, }; const USER_2 = { name: 'Sarah', age: 25, traits: {hair: 'black'}, }; const USER_2_DELTA = { age: 26, traits: {hair: 'green'}, }; const multiSet = [ [&quot;@MyApp_USER_1&quot;, JSON.stringify(USER_1)], [&quot;@MyApp_USER_2&quot;, JSON.stringify(USER_2)] ] const multiMerge = [ [&quot;@MyApp_USER_1&quot;, JSON.stringify(USER_1_DELTA)], [&quot;@MyApp_USER_2&quot;, JSON.stringify(USER_2_DELTA)] ] mergeMultiple = async () =&gt; { let parsedCurrentlyMerged try { await AsyncStorage.multiSet(multiSet) await AsyncStorage.multiMerge(multiMerge) const currentlyMerged = await AsyncStorage.multiGet(['@MyApp_USER_1', '@MyApp_USER_2']) parsedCurrentlyMerged = currentlyMerged.map(([key, value]) =&gt; [ key, JSON.parse(value), ]); } catch(e) { // error } console.log( 'parsedCurrentlyMerged', JSON.stringify(parsedCurrentlyMerged, null, 2), ); // console.log output: /* [ [ &quot;@MyApp_USER_1&quot;, { &quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 31, &quot;traits&quot;: { &quot;hair&quot;: &quot;brown&quot;, &quot;eyes&quot;: &quot;blue&quot; } } ], [ &quot;@MyApp_USER_2&quot;, { &quot;name&quot;: &quot;Sarah&quot;, &quot;age&quot;: 26, &quot;traits&quot;: { &quot;hair&quot;: &quot;green&quot; } } ] ] */ }    ","version":"Next","tagName":"h2"},{"title":"multiRemove​","type":1,"pageTitle":"API","url":"/async-storage/docs/api#multiremove","content":"Clears multiple key-value entries for given array of keys in a batch. Once completed, invokes a callback with errors (if any). Signature: static multiRemove(keys: Array&lt;string&gt;, [callback]: ?(errors: ?Array&lt;Error&gt;) =&gt; void)  Returns: Promise object. Example: removeFew = async () =&gt; { const keys = ['@MyApp_USER_1', '@MyApp_USER_2'] try { await AsyncStorage.multiRemove(keys) } catch(e) { // remove error } console.log('Done') }    ","version":"Next","tagName":"h2"},{"title":"clear​","type":1,"pageTitle":"API","url":"/async-storage/docs/api#clear","content":"Removes whole AsyncStorage data, for all clients, libraries, etc. You probably want to use removeItem or multiRemove to clear only your App's keys. Signature: static clear([callback]: ?(error: ?Error) =&gt; void): Promise  Returns: Promise object. Example: clearAll = async () =&gt; { try { await AsyncStorage.clear() } catch(e) { // clear error } console.log('Done.') }  ","version":"Next","tagName":"h2"},{"title":"useAsyncStorage​","type":1,"pageTitle":"API","url":"/async-storage/docs/api#useasyncstorage","content":"Note: A hooks-like interface that we're experimenting with. This will change in the nearest future to fully leverage Hooks API, so feel free to follow this discussion to learn more. The useAsyncStorage returns an object that exposes all methods that allow you to interact with the stored value. Signature: static useAsyncStorage(key: string): { getItem: ( callback?: ?(error: ?Error, result: string | null) =&gt; void, ) =&gt; Promise&lt;string | null&gt;, setItem: ( value: string, callback?: ?(error: ?Error) =&gt; void, ) =&gt; Promise&lt;null&gt;, mergeItem: ( value: string, callback?: ?(error: ?Error) =&gt; void, ) =&gt; Promise&lt;null&gt;, removeItem: (callback?: ?(error: ?Error) =&gt; void) =&gt; Promise&lt;null&gt;, }  Returns: object Specific Example: You can replace your App.js with the following to see it in action. import React, { useState, useEffect } from 'react'; import { View, Text, TouchableOpacity } from 'react-native'; import { useAsyncStorage } from '@react-native-async-storage/async-storage'; export default function App() { const [value, setValue] = useState('value'); const { getItem, setItem } = useAsyncStorage('@storage_key'); const readItemFromStorage = async () =&gt; { const item = await getItem(); setValue(item); }; const writeItemToStorage = async newValue =&gt; { await setItem(newValue); setValue(newValue); }; useEffect(() =&gt; { readItemFromStorage(); }, []); return ( &lt;View style={{ margin: 40 }}&gt; &lt;Text&gt;Current value: {value}&lt;/Text&gt; &lt;TouchableOpacity onPress={() =&gt; writeItemToStorage( Math.random() .toString(36) .substr(2, 5) ) } &gt; &lt;Text&gt;Update value&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); }  In this example: On mount, we read the value at @storage_key and save it to the state under valueWhen pressing on &quot;update value&quot;, a new string gets generated, saved to async storage, and to the component stateTry to reload your app - you'll see that the last value is still being read from async storage ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}